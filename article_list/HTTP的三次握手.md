[toc] 

<font face="黑体">

# 五层因特网协议栈 TOP
## 一、应用层
* 域名系统
* HTTP协议

---

## 二、传输层
* TCP（Transmisson Control Protocol）
* UDP（User Datagram Protocol）

---

## 三、网络层

---

## 四、数据链路层

---

## 五、物理层

---

## 同OSI七层协议模型、TCP/IP四层模型的区别

----

# HTTP与HTTPS的区别

区别|HTTP|HTTPS
--|--|--|
协议|运行在 TCP 之上，明文传输，客户端与服务器端都无法验证对方的身份|身披 SSL( Secure Socket Layer )外壳的 HTTP，运行于 SSL 上，SSL 运行于 TCP 之上， 是添加了加密和认证机制的 HTTP。
端口|80|443
资源消耗|较少|由于加解密处理，会消耗更多的 CPU 和内存资源
开销|无需证书|需要证书，而证书一般需要向认证机构购买
加密机制|	无	|共享密钥加密和公开密钥加密并用的混合加密机制
安全性	| 弱 |由于加密机制，安全性强



* 对称加密与非对称加密
 对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；
而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。
由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢.

>综上：我们还是用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

* HTTP2
   * HTTP2提高了网页的性能。
   * 在HTTP1中浏览器限制了同一个域名下的请求数量（Chrome 下一般是6个），当在请求很多资源的时候，由于队头阻塞当浏览器达到最大请求数量时，剩余的资源等待当前的6个请求完成后才能发起请求。
   * HTTP2中引入了多路复用的技术，这个技术可以只通过一个TCP连接就可以传输所有的请求数据。多路复用可以绕过浏览器限制同一个域名下的请求数量的问题，进而提高了网页的性能

## 各层对应

# TCP/IP 协议 TOP
## 负责传输的 IP 协议
按层次分，`IP(Internet Protocol)` 网际协议位于网络层，IP协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里,则需要满足各类条件，其中两个重要的条件是 `IP` 地址和 `MAC` 地址 `(Media Access Control Address)`

>IP 地址和 MAC 地址： 指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址，IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。

**使用 ARP 协议凭借 MAC 地址进行通信**

1. `IP` 间的通信依赖 `MAC` 地址
2. `ARP ` 是一种用以解释地址的协议，根据通信方的 `ip` 地址就可以反查出对应方的 `MAC` 地址

## TCP协议是如何保持传输的可靠性

TCP提供一种面向连接的、可靠的字节流服务
1.面向连接

---

# TCP 三次握手和四次挥手 TOP
## 为什么需要握手这个操作？能不能不握手？
 如果对比一下 `UDP` 的通信流程和 `TCP` 的通信流程，可以发现，在 `UDP` 协议中是没有握手这个操作的
 
 ![](leanote://file/getImage?fileId=5c80ba96a9442e46a5000001)
 
 这里就引出了 `TCP` 和 `UDP` 的一个基本区别，TCP是可靠通信协议，而 `UDP` 是不可靠通信协议。
 
>* `TCP` 的可靠含义：接收方收到的数据是完整，有序，无差错的。
* `UDP` 不可靠含义：接收方接收到的数据可能存在部分丢失，顺序也不一定能保证。
 
 `UDP` 和 `TCP`协议都是基于同样的互联网基础设施， 且都基于 IP 协议实现， 互联网基础设施中对于数据包的发送过程是会发生丢包现象的，为什么 `TCP` 就可以实现可靠传输，而 `UDP` 不行?
TCP 协议为了实现可靠传输，通信双方需要判断自己已经发送的数据包是否都被接收方收到，如果没收到，就需要重发。为了实现这个需求，很自然的就会引出**序号（sequence number）** 和**确认号（acknowledgement number）**
发送方在发送数据包（假设大小为 10 byte）时， 同时送上一个序号( 假设为 500)，那么接收方收到这个数据包以后， 就可以回复一个确认号（510 = 500 + 10） 告诉发送方 “我已经收到了你的数据包， 你可以发送下一个数据包， 序号从 510 开始” 。

这样发送方就可以知道哪些数据被接收到，哪些数据没被接收到， 需要重发。

## 三次握手
![](leanote://file/getImage?fileId=5c80c250a9442e46a5000002)

### 第一次握手

建立连接时，向服务端发出连接请求报文，将`SYN`位置为1,Sequence number为x(x是随机生成的一个int数值)，然后客户端进入SYN_SEND（同步已发送状态）状态
，等待服务器的确认

![](leanote://file/getImage?fileId=5c80c460a9442e46a5000003)

### 第二次握手
服务器收到客户端的SYN报文段，需要对这个报文段进行确认，Acknowledgment number为x+1(Sequence Number+1);同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y（y是随机生成的一个 int       数值）；服务端将上述所有信息放到一个报文段(即 SYN+ACK报文段）中，一并发送给客户端，此时服务器进入 SYN_RECV （同步收到）状态

![](leanote://file/getImage?fileId=5c80cbe5a9442e46a5000005)

### 第三次握手
客户端收到服务器的 SYN+ACK 报文段。然后将Acknowledgment Number 设置为 y+1 ,向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务端都进入 ESTABLISHED （已建立连接）状态 。
完成TCP三次握手，客户端与服务器开始传送数据。

![](leanote://file/getImage?fileId=5c80d1f9a9442e46a5000006)

>注：
seq:"sequance" 序列号；
ack:"acknowledge" 确认号；
SYN:"synchronize" 请求同步标志；
ACK:"acknowledge" 确认标志；
FIN:"Finally" 结束标志。

----

## TCP为什么需要三次握手而不是两次握手？
>* 为了实现可靠数据传输，TCP

协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，哪些是被对方收到的。三次握手的过程即是通信双方告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤
* 如果只是两次握手，最多只有连接发起方的起始序列号能被确认，另一方选择的序列号则得不到确认

----

## 四次挥手
![](leanote://file/getImage?fileId=5c80d5bca9442e46a5000007)

### 第一次挥手

客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部 FIN=1，其序列号为 seq = u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入 FIN-WAIT-1（终止等待1）状态。

### 第二次挥手
服务器收到连接释放报文，发出确认报文，ACK = 1，ack = u + 1，并且带上自己的序列号 seq = v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。

>TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。
客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。

### 第三次挥手
服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN = 1，ack = u + 1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq = w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。

### 第四次挥手
服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN = 1，ack = u + 1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq = w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。
第四次挥手：
客户端收到服务器的连接释放报文后，必须发出确认，ACK = 1，ack = w + 1，而自己的序列号是 seq = u + 1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。

>注意此时 TCP 连接还没有释放，必须经过 2MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。

服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。

>可以看到，服务器结束 TCP 连接的时间要比客户端早一些。

## 四次的原因
这是因为服务端的 LISTEN 状态下的 SOCKET 当收到 SYN 报文的建连请求后，它可以把 ACK 和 SYN（ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。     但关闭连接时，当收到对方的 FIN 报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你未必会马上会关闭 SOCKET ,也即你可能还需要发送一些数据给对方之后，再发送 FIN 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 ACK 报文和 FIN 报文多数情况下都是分开发送的.

>由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

# DNS 域名解析 TOP
当你在浏览器的地址栏输入 https://juejin.im 后会发生什么，大家在心中肯定是有一个大概的，这里我将 DNS 域名解析 这个步骤详细的讲一遍。在讲概念之前我先放上一张经典的图文供大家思考一分钟。

![](leanote://file/getImage?fileId=5c80e50fa9442e46a5000008)

## 查找域名对应的 IP 地址的具体过程
1. 浏览器搜索自己的 DNS 缓存（浏览器维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步；
2. 搜索操作系统中的 DNS 缓存；如果没有命中，进入下一步；
3. 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；如果没有命中，进入下一步；
4. 
>1. 操作系统将域名发送至 LDNS （本地区域名服务器），LDNS 查询自己的 DNS 缓存（一般命中率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求：
2. LDNS向 Root Name Server（根域名服务器，如com、net、im 等的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 im 域的顶级域名服务器的地址；
3. LDNS 向 im 域的顶级域名服务器发起请求，返回 juejin.im 域名服务器地址；
4. LDNS 向 juejin.im 域名服务器发起请求，得到 juejin.im 的 IP 地址；
5. LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来。

# 五类 IP 地址 TOP
# 跨域的原因及处理方式 TOP
出现跨域的原因是由于 浏览器的同源策略 所决定的。

>同源策略限制了同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用户隔离潜在恶意文件的重要机制

* 同源的定义

>如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。


下表给出了相对http://store.company.com/dir/page.html同源检测的示例:

URL|结果|原因
--|--|--|
http://store.company.com/dir2/other.html|成功| |
http://store.company.com/dir/inner/another.html|成功| |	 
https://store.company.com/secure.html	|失败	|不同协议 ( https和http )|
http://store.company.com:81/dir/etc.html|	失败	|不同端口 ( 81和80)|
http://news.company.com/dir/other.html	|失败	|不同域名 ( news和store )|
# 正向代理和反向代理 TOP
# CDN 带来的性能优化 TOP

>CDN的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。

>CDN 的核心点有两个: 一个是缓存，一个是回源。
## 关键技术
1.内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处；

2.内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程 POP 上均衡用户的请求，以使用户请求得到最近内容源的响应；
3.内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在POP的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量；

4.性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。
## CDN & 静态资源

 

# HTTP 强缓存&协商缓存 TOP
</font>


